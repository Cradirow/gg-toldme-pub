Development Progress
====================

2018/01/23
----------

1. **메인컨셉 : 마왕시점의 탑뷰 실시간 디펜스 SRPG**
	- 던전에서 **n세대**를 거듭하며 쳐들어오는 용사들을 막아라.
	- 던전은 여러개의 출입구와 한개의 보스방으로 이루어져있다.
	- 용사가 마왕이 있는 보스방에 도달하면 게임오버.
	- 한 스테이지(컨셉이 있는 맵(마을))에 있는 용사의 씨를 말리면(ex. 100세대)스테이지 클리어
	- 임의의 출입구로 용사들이 쳐들어오며, 세대간 출현 간격은 다이나믹한 긴장감을 유지할 수 있도록 적절하게 조정한다. 갈수록 빨라져도 괜찮을듯. (여러세대가 동시에 던전안에 존재할 수 있다. 증조할아버지와 만나거나 하는 등의 개그요소, 이스터에그 가능성)
	- 용사들은 세대를 거듭하며 지능이 높아져 보다 효율적인 루트로 쳐들어오거나, 체력이 높아져 맷집이 좋아지는등 다양하게 발전한다.
	- 마왕은 커서위치로 스킬을 쓸 수있다(쿨타임).
	- 용사들은 말풍선등으로 재잘재잘 거리며 돌아다닌다.
	- 몬스터를 생각없이 마구 배치하다가는 다른곳에서 들어온 용사들에게 토벌당한다.
	- 용사들의 코스튬도 점점발전하거나 바뀐다.(처음엔 원시시대 돌도끼~ 미래 SF 광선검 등등, 탈것도 나오고 벽도 넘어다닌다.)
	- 미믹같은 몬스터를 곳곳에 배치하여 보물상자로 속임.

2. **추가요소**
	- 스테이지 별로 무한모드로 n세대까지 막아냈나로 랭킹 경쟁
	- 몬스터 또한 과금요소로 추가할 수 있을듯.
	- (번외 스테이지로 파밍 스테이지를 만들어 그곳에서 파밍한 몬스터들을 감옥에 넣고 스테이지에서 하나씩 배치할 수 있다.)
	- PC base 에 모바일은 2배확대 기능에 미니맵(간단하게 8방향 화살표로 용사출현정보만 알려준다던가)으로 구현한다.
	- 마왕은 징집or사냥or생포한 몬스터, (용사)를 적절한곳에 실시간으로 배치하여 용사들을 저지한다.
	- 징집의 경우에는 감옥(몬스터 풀)에 각 몬스터별로 다른 쿨타임마다 한마리씩 채워지는 몬스터를 배치할 수있고, 풀의 크기만큼 모아둘 수 도 있다.


2018/01/26
----------

1. **맵 제작**
	- 맵은 49/49 사이즈로 7/7 사이즈의 방을 이어붙여 제작했다.(데모)
	- 하나의 방에는 문이 1, 2개 존재하고 몬스터, 함정이 존재할 수 있다.
	- 스마트한 용사일수록 함정을 간파하고, 문으로 가는 최단거리를 잘 알 수 있다.

2. **진행 사항**
	- ` TVNT > Pattern Settings ` 에서 X축 크기를 정할 수 있다.
	- 문은 자동으로 바로 앞 타일에 가면 열고 닫힌다. ` Invoke() ` 함수를 사용하였다.
	- AIController는 몬스터에 스크립트로 적용되어 있다.
	- 버튼에 문을 맵핑해서 열릴 문을 지정할 수 있다.
	- Enemy Spawner를 이용할 때 직접 Enemy 프리팹을 넣어줘야 정상적으로 작동한다.
	- 컨트롤러는 AI컨트롤러와 Player컨트롤러로 나뉜다. 이 때 ` Move Time `은 오브젝트가 움직이는 속도.
	- ` Barrier / Ground ` 를 Layer Mask에 설정해주어야 한다.

3. **보완 사항**
	- 문이 닫힐 때 속도 제어할 것.
	- 또한 버튼 위에 있을 때 문이 계속 열려있어야 한다.
	- AIController 를 응용해서 용사의 움직임을 제어할 것이다.
	- 아니면 문 위에 슬라이드 타일을 적용시켜 자동으로 가게끔 해도 될 듯. (스크립트 참고)


주말에 컨트롤러 스크립트 뜯어볼 것!



2018/01/31
----------
~~헤세드 워프 6일차 : 개발자들이 멘붕에 빠지기 시작했다.~~

1. **스크립트 코딩**
	- ` HeroContorller.cs ` 파일을 제작해 ` TVNT > TVNT > Scripts > CharacterController ` 폴더에 넣어주었다.
	- 히어로 컨트롤러는 기본적으로 ` AIController.cs `스크립트의 함수 구성을 토대로 하였다.
	- 히어로 컨트롤러는 Start()문에서 버튼타일을 모두 불러와 배열에 담고, 그 중에서 랜덤적으로 선택된 버튼으로 이동한다.
	- 여기서 버튼이란 문으로 이동하는 디딤돌을 하는 타일이다. 문 바로 앞뒤 혹은 양옆으로 달려있다.
	- 하나의 방을 구분하는 것은 문이기 때문에, 문을 넘는 것은 다른 방으로 이동한다는 것을 의미한다.
	- 이 때 몬스터가 끼어들면 몬스터를 우선적으로 따라가기 때문에, 랜덤성을 더 부여할 수 있다. (*추가예정*)

2. **보완 사항**
	- 몬스터가 끼어들지 않는 상황에서 무한 루프를 도는 경우가 있다.
	- 이 경우를 해결하기 위해 용사들에게 새로운 특성을 선물해주기로 하였다. 그것은 '용사의 수명'이다.
	- 아니면 스페셜 타일을 깔아서 하드하게 길을 맵핑하는 방법이 있다. ★
	- 2차원 배열을 만들어서 방마다 하나의 차원에 버튼들을 넣어서 방의 스위치에 Type을 넣어서 밟을 때마다 바뀌게끔 구성하는 방법이 있다. ★★

3. **용사 스탯**
	1) 체력 : 용사는 체력이 다 닳으면 죽게된다. 몬스터에게 피격되면 해당 몬스터의 (데미지 - 방어력)만큼 체력이 깎인다.
	2) 수명 : 용사들은 수명이 있다. 이는 세대가 진화할수록 늘어나며, 기본적으로 용사 Object가 생성된 시간을 기준으로 한다.
	3) 힘 : 힘은 용사의 타격 데미지를 정의하는 중요한 요소이다. 세대가 진화할수록 강해지지만, 늙을수록 약해진다.
	4) 민첩 : 민첩 역시 힘 스탯과 마찬가지로 용사의 이동속도를 제어한다. 진화할수록 빨라지지만, 늙을수록 느려진다.
	5) 지능 : 용사들의 지능 또한 갈수록 발전한다. 처음에는 뺑뺑이를 돌 확률이 굉장히 높지만, 갈수록 최단거리의 길을 손쉽게 찾아낸다.
	하지만 현재 개발한 코드로는 쉽게 구현할 수 없다.. ` ButtonTile `을 인식하는 범위에 대한 수정이 들어가면 가능할지도.
	6) 운  : 용사가 보물상자를 개봉했을 때 좋은 버프(?)를 얻을 확률이 높아진다.

4. **게임 컨셉 추가**
	- 말풍선 대사 : 용사를 클릭하면 랜덤으로 상황에 처한 말풍선이 나온다. 자세한 것은 ` 말풍선 DB ` 참고.
	- 유가족 : 용사가 던전에 들어갔을 때 용사의 유가족들이 밖에서 기다리고 있다. 물론 그들을 클릭하여도 말풍선이 나온다.


2018/02/02
----------
1. **개발 현황**
	- 5x5 사이즈의 타일을 하나의 방으로 생각하고, 총 49개 방이 들어갈 수 있는 맵을 구성하였다.
	- 각 테두리부터의 타일을 각각 Level으로 구분하여 Level1, 2, 3 그리고 Level4(보스방)의 태그를 주었다.

2. **스크립트 코딩**
	- 용사는 자신의 위치에서 가까운 방 두 개를 인식하여 랜덤으로 이동한다.
	- 이 때, 방을 인식하는 기준은 `heroSpawnController.cs`에서 설정해준 route 배열을 기반으로 한다.
	- route배열은 int형 정수를 총 50개 담을 수 있으며, 각각에는 level의 숫자가 들어간다.
	- 현재 문제점은, 모서리 부분에서 상위 level로 가라는 명령이 떨어질 경우이다.
	- 이 경우는 `findLevel1Room()`함수를 한번 실행시키고, iterator를 하나 줄여주는 방법으로 해결하자.

~~@Laki16은 알고리즘을 다 짰다고 생각한다. 그런데, 짜잔!~~


2018/02/04 & 2018/02/05
-----------------------
1. **향후 계획**
	- [C#] Door.cs : 문 앞에 갔을 때 문이 자동적으로 열리는 스크립트 추가. (Collider 이용)
	- [C#] heroSpawnController.cs : 용사들의 리젠을 컨트롤하는 스크립트
	- UI 제작 : 몬스터를 끌어와서 배치하는 창 제작
	- 맵 텍스처 제작, 몬스터 종류 다양화, 용사 코스튬 다양화..

2. **개발 현황**
 `heroSpawnController.cs` 작성 완료
	- 기존 Character를 비활성화 한 뒤에 `initiate`메소드를 이용해 클론하여 세대별로 히어로를 계속 젠 시킨다.
	- 젠 시간은 현재는 5초로 설정했고 점점 줄어들면서 빨리빨리 젠되는 형식으로 할 계획.
	- `spawnCount`를 이용해 몇 세대를 젠시킬 것인지 설정
	- `heroController.cs`에 있던 모서리(Edge) 관련 버그를 수정하였다 : 배열에서 연속된 숫자가 나올 경우 (예. 1-2-3-4) 한단계 밑으로 되돌아가는 경우에 있어서 두 칸이 차이나게 되어 무한루프를 도는 경우가 있었는데, 어차피 count가 일정이상으로 높게 올라가게 되면 해당 레벨로 향하게 되므로 문제 없음.
	- 원래는 리소스문제가 아닌가 싶었는데, 무한루프가 돌아서 생기는 문제였음.
	- 그래도 100세대를 다 소환하게 된다면 분명 리소스 문제가 있을 것이다.
		> 해결 방법 1. 맵에 존재할 수 있는 용사의 수를 제한한다.


		> 해결 방법 2. 죽은 용사를 재활용한다.
	- 몬스터도 마찬가지로 재활용을 하면 리소스 부분에서 이득일 것으로 예상된다.



2018/02/06
----------
1. **개발 현황**
`heroController.cs` 작성 완료
	- `checkMonster` 메소드 : 용사 주위 반경으로 4만큼의 원에 들어오는 몬스터가 있을 경우 몬스터를 감지하는 메소드이다.
	- 이 메소드 안에는 함정을 감지하는 `DungeonWeapon` 태그와 몬스터를 감지하는 `Smashable` 태그가 있다.
	- 메소드가 실행될 때마다 현재 용사의 체력을 체크하여 0밑으로 떨어질 경우 `LifeLost` 메소드를 실행하여 용사가 없어지도록 작성하였다.
	- Smashable 태그를 감지한 경우(몬스터의 경우) 몬스터를 임시 target으로 설정하고 그쪽으로 향하게 하였다.
	- 이렇게 하고 나니 몬스터를 바라보지 않은 채 때리는 경우가 생겼다 : `characterTurn` 메소드를 이용하여 해결.
	- 또한 Sword 애니메이션을 추가하여 몬스터 타격시 팔을 휘두르는 모션을 설정하였다.

2. **참고 사항**
> `checkMonster` 메소드에서 `isMonster` 와 `isTurn` 변수가 중요한 역할을 한다. 둘 다 bool함수로 설정되어 있는데, 각각 임시로 타겟을 저장하는 것과 몬스터쪽으로 한번만 회전하는 기능에 관련이 있다. 하지만 약간 알고리즘적으로 더 깔끔한 방법이 있을것 같다.



2018/02/07
----------
1. **개발 현황**
`heroSpawnController.cs` 완성
	- 맵에 존재할 수 있는 용사의 수 제한.
	- `heroList.Count`사용하여 현재 맵에 용사가 5명(수정가능)이 넘으면 더이상 생성되지 않게 함.(`Coroutine 사용`)
	- 생성될 때 `heroList`에 `hero + respawnCount`로 `add`
	- 없어질 때 `heroList`에 `characterDead()`로 해당 용사를 `removeAt()`
임시적으로 hero 죽는 부분 구현
	- `HeroController.cs`에 주변의 오브젝트들 중 태그가 "Player" 를 인식 (여기서 자기자신은 제외하게) 하면 서로 공격하며 사라지게 구현 (heroSpawnController에서 없어짐)

2. **향후 계획**
	- [C#] Monster 1~a .cs : Slime 말고 다른 Monster 스크립트를 만들어서 용사에게 공격하게 한다.



2018/02/15
----------
1. **UI 개발**
	- 미니맵을 표시하기 위해서 ` MinimapCheck.cs `와 ` MinimapScript.cs `를 추가하였다.
	- 미니맵은 큐브로 구성되고, 큐브에 ` MinimapCheck.cs `가 포함된다.
	- 여기에서는 ` bool isHero `변수에 따라 타일의 색깔을 변경한다.
	- ` MinimapScript.cs `에는 용사가 레이를 쏘고, 레이에 맞은 타일의 isHero값이 바뀌어 색깔이 바뀌게 된다.
	- 이제 MinimapRenderTexture파일을 만들고, 사이즈를 조정한 다음에 Depth Buffer를 No Depth Buffer로 바꾼다.
	- 미니맵을 위한 카메라를 만들고 Target Texture에 MinimapRenderTexture를 넣어주자.
	- 마지막으로 하이라키에서 Canvas > Raw Image를 만들고 Texture에 MinimapRenderTexture를 넣어주면 미니맵 완성.
	- 캔버스 생성, panel 들로 UI 구성
	- panel 안에 세부적인 panel 및 button으로 몬스터, 스킬 UI 구성
	- button CoolDown Effect 완성 (`ButtonCoolDown.cs`)
	- Scrollable Buttons 구현

2. **향후 계획**
	- minimap 에 isHero 변수초기화 함수 `InitColor()`를 코루틴이나, deltaTime을 써서 성능간 점멸수 차이를 보완한다.
	(현재는 성능에 따라 점멸빈도가 차이남)
	- modeling, texture는 우리가 새로 만들기로.
3. **참고 Key 기술**
	- [미니맵 Raw Image] (https://www.youtube.com/watch?v=28JTTXqMvOU)
	- [CoolDown Operation] (https://www.youtube.com/watch?v=6dQjLoupAw0)
	- [Scrollable Buttons] (https://www.youtube.com/watch?v=lUun2xW6FJ4)

ps. 현재 버전에서 실행 시 Game뷰로 가서 종횡비를 16:9로 바꿔야 정상출력됨


2018/02/16
----------
1. **수정사항 보완(lightly)**
	- minimap 점멸 문제 해결
	- > `MinimapCheck.cs`에 Hero가 방에 있는지를 확인하기 위한 `isHeroTrueTime`과 Hero가 방안에 없다는 것을 판단할 시간단위
	 `defaultIsHeroFalseTime`을 각각 1.0f 로 설정했다. 그 후, Hero의 Ray가 큐브에 hit 할때 발동하는 `ActivateIsHero()`함수를 구현하여 큐브를 점등시키고 `isHeroTrueTime` 이 0.0f보다 클 때(무한정 작아지는것을 방지하기 위해서(방안에 있는 시간은 완전히 랜덤하므로 무한정 작아질 경우 방안에서 없어진 경우를 판단하는데에 문제가 생긴다.또한 여러명이 있을때도 문제가 생길 소지가 있다.)) `2*deltaTime`만큼 감소시킨다.
	 그리고 `isHeroTrueTime`이 앞서 설정한 `defaultIsHeroFalseTime` 보다 작을 경우에(히어로가 방안에 있거나 있었을 경우)
	 `isHeroTrueTime`을 `1*deltaTime`만큼 증가시킨다.(여기서 감소시키는 값이 증가시키는 값보다 크므로, hero 가 방에 들어오자마자 안정하게 점등된 상태를 보장할 수 있게 된다.)
	 마지막으로 `isHeroTrueTime`이 `defaultIsHeroFalseTime`보다 크거나 같을경우 `DeactivateIsHero()`를 통해 큐브의 불을 끄고,
	  `isHeroTrueTime`을 초기값으로 복구시켜준다.
	- minimap 점멸 문제 해결 2
	- > 위와 같은 방법으로 할 시에, 처음 딱 시작했을때 점멸이 한번 발생하는 버그가있다. 처음 함수들이 실행되고 update문이 실행되는데 걸리는 텀이 문제로 추정. 따라서, 그냥 `ActivateIsHero()`로 `isHeroTrueTime`을 0.0f로 계속 설정해주는 것으로 해결했다.

	- `HeroController.cs` 에 구현되어있는 `if (hitColliders[i].gameObject.tag == "DungeonWeapon" && invincible == false)`부분은 `TVNTCharacterController.cs`에 `OntriggerEnter()`로 구현되어있으므로 삭제 검토.

2. **MonsterAIController 도입**
~~졸려죽겠다..! 내일적는다!!!~~
	- KeyPoint!
	> //경계범위안에서 히어로가 빠져나갔는지를 판단하기위한 시간단위
      //히어로가 들어오면 이 alertTime을 감소시키고(혹은 minimap 버그와 동일한 오류가 발생할경우 일정 숫자(0)로 바꾸어주고),
      //히어로가 범위안에서 빠져나가면 천천히 증가되어 기존 설정단위 이상이된다면 진정(relax)상태(추적중단, 인식해제)
      //히어로가 '은신'스킬을 쓸경우 이 alertTime 감소를 시키지 않거나 적게 시키고, 발각되면 급격히 감소시키는 방법도 고려
      //히어로가 '섬광탄'등을 사용할 경우 이 alertTime을 급격하게 늘려 일정시간 인식하지 않게 하는방법도 고려(이경우에는 기준치 이상으로 올라갈 경우의 예외처리 해줘야함)
      기타 자세한 사항들은 주석에 달아놓았음. ~~추가로 정신이 말짱할 때 여유가되면 더 적도록 한다.~~


2018/02/17
----------
~~내일이 밝았습니다~~
1. **진행 사항**
	- 용사의 ` HeroController.cs`에서 각종 버그를 수정하였다.
	- 일단 몬스터를 만났을 때 방향이 제대로 바뀌지 않는 부분을 픽스하였고, 어떻게하면 타겟을 하나 잡고 유지시킬 수 있을지 고민하였다..
	- 하지만 생각보다 괴랄한 코드구성으로 인해 OverlapSphere를 넓게 잡아서 여러 마리의 몬스터를 인식시킨 뒤에 그것을 어떻게 유지시킬지는 조금 난해하다.
	> 일단 이 알고리즘은 추후에 생각하자.
	- ` MonsterAIController.cs `는 대체적으로 ` HeroController.cs `를 참고하여 작성하였다.
	- 다만, isHero라는 bool 변수를 넣어서 일정 범위에 용사가 들어오기 전까지는 움직이지 않게 하였다.

2. **보완 사항**
	- 용사와 몬스터가 n:n으로 만났을 때 나타나는 움직임 버그
	- 용사와 몬스터가 1:n으로 만났을 때 한명이 다수를 한꺼번에 공격하는 버그

3. **말풍선 UI 진행**
	- 말풍선은 NGUI나 UGUI 따위를 통해서 제작하려고 했으나, 에셋이 유료라는 점과 말풍선을 적용하였을 때 깔끔하지 않다는 점 때문에 text mesh를 사용하게 되었다.
	~~결코 에셋이 비싸서 그런거 아님~~
	- text mesh는 용사의 ` Empty Object `안에 넣어서 위치를 조정할 수 있게 하였다.
	- 이제 ` chatController.cs `를 통해서 대화를 나타내고 지울 수 있게 됨.
	- 대화 DB는 ` chat.md `를 참고할 것.


2018/02/18
----------
~~사실상 17일 철야........~~
1. **진행 사항**
	- `SpeechController.cs` 도입 (~~노가다의 산물~~)
	> 리스트로 `ChatDB`를 구현한다(`awake()` 로 Hero Instantiate 될 때 초기화).
	  `Speech Method` 는 각 상황에 맞는 말풍선 DB 안에서 랜덤하게 한가지 선택하여 그 상황을 트리거로(`SetCurrentSpeechType()`을 통해서) 전달했을 때 말풍선을
	  `Instantiate` 하고
	  `speechBubbleDestroyTime`후에 `Destroy()`하게 했다.
	  말풍선은 `부모의 position`과, `부모의 rotation * popUpRotation`, 부모의 자식으로 Instantiate된다.

2. **보완 사항**
	- `SpeechController.cs`
	> `SetCurrentSpeechType()` 구현하기(Hero에서 적절한 상황을 트리거로 전달할 수 있어야한다. 적절한 상황을 판단하는 방법도 고려.)
	  말풍선이 조금 더 잘 보이게 위치 수정해보기.

	- `HeroController.cs`와 `MonsterAIController.cs` 위의 문제 아직 미해결
	(~~오...오늘은 이제그만!~~)

2018/02/19
----------
1. **목표**
	- ai수정, 드래그앤 드롭 몹 배치, 드래그 화면 이동, 타이틀화면 캔버스 적용, 함정 적용, 몬스터, 가족 에셋이용(프로토타입)

2018/02/20
----------
1. **진행 사항**
	- `HeroController.cs`보완, `WeaponController.cs`를 추가하였다.
	- 3D모델링(~~큐브노가다~~)을 통해 몬스터 한마리와 화살, 칼을 추가하였다.
	- 각각의 무기는 프리팹으로 따로 저장해 두었다.
	- 또한 화살을 쏘는 애니메이션을 추가하였다.
	- 애니메이션을 추가할 때는 추가할 캐릭터(Character_1)를 하이라키에서 클릭하고, ` Window > Animation ` 을 클릭한다.
	- `Create New Clip`을 클릭하고, 이름 입력 후 녹화버튼을 클릭한 뒤에 하이라키에서 움직일 팔다리 따위 오브젝트를 클릭해서 각도나 크기, 위치를 조정한 뒤에 (피벗을 추가해야 하나?) 드래그로 시간조절을 해주면 된다.

2. **Particle Effect**
	- 소드맨에 담긴 ` PS.hit `는 유투브를 참고하여 제작하였다. 솔직히 별거 없음.
	- 이제 활쟁이의 스킬샷 (관통형) 이거는 활에 달아서 발사할 때 실행되게 하면 속도를 활이랑 잘 맞추면 될듯.
	- 매지션의 파이어볼을 개발해보자. ~~끄악~~

3. **모델링 개발**
	- Dummy 용사 모델을 추가해야 한다.
	- 맨몸으로 만든 뒤에 갑옷을 따로 제작해서 입히는 방식으로 해야 함. 객.체.지.향.적이랄까 후훗?
	- 맵에 텍스쳐를 입혀야 한다. 텍스쳐는 에셋에서 찾아보는게 빠를듯.
	- 만약 텍스쳐에 따라 잘 움직이지 않는 경우 terrain이나 tilemaker를 통해서 만들면 될듯하다.

2018/02/24
----------
1. **진행 사항**
	- `Threat 기능 보완`
	- 기존 문제점(추정)
	- 델타타임 만큼 threatenTime 을 조정하기 위해서 update 에 threat()을 넣은 결과,
	히어로 5명이 1프레임 안에 한 몬스터에게 각각 총 5번 threat()를 해서, 1/5프레임에 한번씩 betweenDiff가 변하는걸 목적으로 했으나, 실제적으론
	프레임 1 : Hero1,2,3,4,5 /
	프레임 2 : x /
	프레임 3 : x /
	프레임 4 : x /
	프레임 5 : x /
	프레임 6 : Hero1,2,3,4,5 /
	이렇게 되어서 결과적으로 hero5와의 betweenDiff만 고정되는 것으로 추정한다.
	- 해결방안
	- 기존의 단일방향 접근만 가능했던 Hero-HeroSpawnController에서 양방향 접근이 가능하게 Hero에 heroSpawnController 를 생성해줬다.
	heroSpawnController에는
	threatControlTrigger 변수를 넣어서 Hero에서 제어를 해줌으로써, list 상 앞의 히어로의 threat 메소드가 완료되어야만 다음 hero의 threat 메소드가 작동되도록 해서, 한 몬스터의 한 프레임안에 여러번의 threat 메소드가 실행되지 않도록 했다.
	- MonsterAIController.cs 의 ThreatHero() 보완
	- 기존 문제점
	- Hero와의 거리가 5.0f 미만일 때, isHero를 켜서 Update문 안의 움직임을 제어했으나, 이미 이동중에 isHero가 true로 될 경우에, 거리가 8.0f로 늘어났는데 isHero가 켜져있어, 멀리떨어져있는 상태로 고정되는 문제가 발생
	- 해결방안
	- 2칸 이상 떨어져있는 경우에 대한 예외처리를 해줌.


2018/02/26
----------
이젠 정말 개발 뿐이야

**1.향후 계획**

	- 1주차 02/26 ~ 03/03 모든 코딩 완료.
		- 공격 부분 : 투명한 오브젝트 생성하여 범위공격 데미지 주기
		- UI및 시스템 : 히어로 죽었을 때 코인 드랍, 몬스터 되팔기, 스킬 사용, 용사 말풍선 항상 카메라 시점으로 보이게 수정
		- 맵 구성 : 맵 세개까지 늘리기, 맵에 오브젝트 늘리기
		- 용사 세부 능력치 설정
		- 파티클은 에셋을 구매해 사용하도록 하자.
		- 애니메이션은 금방 제작할 수 있음.

	- 2주차 03/04 ~ 03/11 모델링 완료.
		- UI 디자인 개편
		- 용사 세대별 및 직업별 디자인, 무기 디자인, 갑옷 디자인, 몬스터 디자인
		- 추가적인 오브젝트는 상황에 따라 진행

	- 3주차 03/12 ~ 03/18 모든 세부 스크립트 완료. 사운드 설정 완료
		- 몬스터별 모션, 중간보스급 몬스터들에 대한 개개인 스크립트를 달아주어야.
		- 사운드는 가까이가면 조잘대는 소리가 들리게 구성할 것.
		- 타격 사운드, 몬스터별 사운드도 제작해야 한다.

	- 4주차 03/19 ~ 03/25 버그 픽스 및 성능 확인, 포트폴리오 및 홍보자료 제작, 어워드 제출

	- Made with Unity 2018 Award 제출일 : 3월 21일
		- 우리는 학생 Top3 작품을 노린다.
	- Google Indie Game Festival 제출일 : 3월 25일
		- 우리는 Top 20 안에 들기를 원한다.

**2.Today's Develop**
	- 공격부분 개발 스타트.
	- 검기 개발 : 활처럼 firePosition에서 막대기를 하나 만들어서 회전을 시키자(앞으로 움직이지는 않음). 검기의 범위는 용사 앞 세 블럭이다.
	- 마법사 파이어볼 추가 : 화살 스킬샷과 다를 바 없이 구성하자. 파티클 이펙트만 변경하면 됨.

2018/02/27
----------
**1.검**
- 검은 일반적으로 큐브를 이용해 공격하도록 구성하였다.
- 들고있는 검으로 때리는 것이 아니라, 공격을 할 때 해당하는 범위만큼 큐브가 생겼다가 사라지는 것이다. 이는 다른 스킬이나 활, 마법 클래스에도 공통적으로 적용되는 부분이다. (사이즈만 다를 뿐)
- 검 일반공격 : 앞으로 한 칸 공격. 이펙트는 맨 처음 만들어놓은 `PS.hit`를 사용
- 검 스킬공격1 : ~~바람의 상처!~~ 앞으로 한 칸, 왼쪽 위 대각선 한 칸, 오른쪽 위 대각선 한 칸 공격. 이펙트는 휘두르는 모션에 따라서 발동되게끔 하자. 초록색 이펙트가 나가면 좋을 듯?
- 검 스킬공격2 : ~~이즈 궁~~ 앞쪽으로 쭉 공격. 스킬공격1이 앞으로 8칸 정도 나간다고 생각하면 될 듯. 이펙트는 노란색 + 하늘색으로 Slash Effect 검색해볼 것.
- 스크립트 부분은 간단하게 구성했다. 큐브를 만든 뒤에 단순히 mesh를 지워서 collider간 충돌을 OntriggerEnter()로 제어하게 하였다.

**2.화살**
- 화살은 얇은 화살이 실제로 발사된다.
- 히어로의 `firePosition`에서 발사되며, initiate를 할 때 각도를 `Vector3.forward`로 하면 이상하게도 뒤쪽에서 발사되어 `firePosition`을 y축으로 180도 회전시켰다. (물론 `Vector3.back`으로 하면 문제 없을 듯..)
- 활 일반공격 : 몬스터가 사정거리에 들어오면 그쪽을 향해 일직선으로 발사. 몬스터가 회피할수도 있다. 이펙트는 맞을 때 피격이펙트를 넣으면 되겠다.
- 활 스킬공격1 : 관통형 화살을 발사한다. 다만 한 몬스터가 중복적으로 쳐맞는 경우가 있어서 `arrowSkill1Attack.cs`에서 isPass 불리언 변수로 제어하였다. 관통형 화살은 파티클 이펙트와 함께 발사되는데, 딜레이 시간을 2초로 두고 시간을 맞춰주어야 하겠다.
- 활 스킬공격2 : 화살이 위에서 쏟아지는 식으로 구성하면 어떨까.. 일단은 법사클래스와 비슷할 수도 있고, 이펙트를 구성하는 것이 쉽지 않을 것 같다.
- 스크립트 부분은 `Vector3.forward`를 적극적으로 사용해 구성하였다. 중복되는 부분을 걷어내니.. 띠용! 2~3줄만에 구성되어버렸다.
- `arrowNormalAttack.cs`와 `arrowSkill1Attack.cs`가 다른 점은 단지 OntriggerEnter()에서 충돌이 일어났을 때 GameObject.Destroy()메소드를 이용해 자기 자신을 없애는 것이다.

**3.마법(작업 중)**
- 조그만 구체(Sphere)가 날아간다.
- 활과 마찬가지로 `firePosition`에서 발사된다. 나머지 구성은 활과 비슷하다.
- 마법 일반공격 : 에너지 구체를 발사하자. 피격이펙트를 그 구체가 터지면서 약간 감전되는 식으로 구성하면 멋있겠다.
- 마법 스킬공격1 : 얼음 메테오 발사. 시전시간과 데미지가 다른 클래스의 스킬공격보다 길고 약한 대신에 범위는 좀 더 넓게 구성하자. 캐릭터 앞 6칸이 적당할 듯.
- 마법 스킬공격2 : ~~예토전생 : 증조할아버지를 소환해서 끌고 다닌다.~~

**4.애니메이션(작업 중)**
- 검 기본공격 : 좀 더 박력있고 빠르게 벤다는 느낌으로 수정할 것.
- 검 스킬공격1 : 점프해서 위에서 아래로 몬스터들을 후려친다.
- 검 스킬공격2 : 바닥을 오른쪽에서 왼쪽으로 긁으면서 검기를 발사한다.
- 활 기본공격 : 장전해서 발사하는 일반적인 구성으로.
- 활 스킬공격1 : 좀 더 오래 장전하고 기를 모아서 쏜다는 느낌으로 구성.
- 활 스킬공격2 : 위로 장전해서 쏘는 식으로 구성해보자.
- 마법 기본공격 : 지팡이를 휘두르는 식으로 구성
- 마법 스킬공격1 : 지팡이를 회전시키면서 기를 모으고 내려치는 식으로 하면 될 듯.

~~100커밋 가즈아아아아~!~~

2018/02/28
----------
**에셋 쇼핑의 날**
- 파티클 이펙트(타격, 검, 화살, 마법, 보스 스킬 등등) AdvancedKyMagicFX03 /publisher : kakky
- 캐릭터, 맵 모델링 Cube : heroes and dungeons pack
- 몬스터 모델링(아직 구매 x) Cube 형식 모델링.

2018/03/01
----------
시스템 컨셉
----------

**시나리오 모드**
 - 밤이되면 용사,몬스터 전부 잠든다. 잠들때 데려와서 배치할 수 있음. 이때 인게임 재화 필요.
 - 인게임 재화는 기본 1웨이브때 배치할만큼 적당히 기본지급하고, 이후 인게임 안에서 꾸준히 상승함.(맥시멈 있음)
 - 스테이지보상 = 히어로 킬 보상. 죽일때마다 글로벌재화 획득.
 - 유닛 업그레이드 및 언락, 마왕 업글(스킬 쎄짐)은 아웃게임 메뉴에서 가능
 - 유닛 뽑기 및 업그레이드 가능.(C~A급은 글로벌재화(골드), S급 젬. S+급 젬X100 같은 식)
 - 유닛은 지속적으로 신규유닛 추가. 능력치도 다 다름. 에픽, 영웅 유닛 추가.
 - 사용할 유닛 슬롯을 지정. 자기가 그 스테이지에서 쓸 유닛을 미리 선정.
 - AD로 일정시간 혹은 일정 스테이지 글로벌재화 획득량 증가 아이템등 설정(용사가 부자가된다. 그 마을에 석유가 터졌다 등등)
 - 정복한 마을의 용사들은 노예로 부릴수 있다. (지속적인 글로벌재화 획득구조)
 - 노예는 복지시설을 업그레이드 시킴으로써 지속적인 글로벌재화 획득량 증가.
 - 많은 스테이지를 정복할수록, 노예들이 많아짐 = 글로벌재화 획득량 증가.
 - 유닛 업그레이드 및 복지시설 업그레이드는 갈수록 필요량 증가.(인플레이션)
 - 가끔 노예들이 마을을 탈환해서 스테이지 재사용 가능.

**온라인 모드**
 - 기본 컨셉은 다른 유저의 몬스터 유닛을 히어로로 사용해서 막는것.
 - 온라인 모드에서 사용할 몬스터 슬롯에 유닛을 배치해줌.
 - 다른유저에게 도전할 때 그 몬스터슬롯을 히어로로 사용해서 방어(= 마을을 먹는것. 정복. WIN)
 - 다른유저의 몬스터 슬롯 파싱.
 - 방어에 성공했을때 상대유저와 랭킹 바뀜.(점수제로 하는게 더 좋을지도)
 - 하이랭커 주단위 보상 추가.
 - 시나리오 모드 끝나면 엔드콘텐츠는 아레나.
 - 유닛업그레이드나 유닛등급 나한테 없는 좋은 유닛 등으로 경쟁 유도.
 - 길을 막을수 있는 오브젝트를 어느정도 줘서 길도 만들고, 적절한 유닛사용으로 컨트롤 요소 확보.

2018/03/04
----------
에셋을 대대적으로 바꾸어 적용하였다!

단 TVNT 리펙토링은 너무 복잡한 관계로 살려두고 맵, 몬스터, 파티클이펙트, UI 등을 구매해 적용하는 과정에 있다.
Stage 1-1의 맵을 이용하여 계속 데모버전을 돌리고 있다.
 - TVNT의 특성을 살리되, 흔적을 없애기 위해 `TVNT > LevelTilesPrefab` 에서 Ground의 MeshRender를 꺼두었다.
 - 다만, 기존 Hero를 에셋에 있는 캐릭터로 변경하는 과정에서 애니메이션과 공격적인 부분의 싱크를 계속 맞춰야 한다.

현재까지 알아낸 정보 :
 - 애니메이션 추가 방법은 기존과는 약간 다르다.
 - 일단 큰 틀의 Hero안에 아바타를 넣고 Animator inspector에 아바타를 넣어준다.
 - Base에서 Idle, Walk, 기타 스킬이나 일반공격 trigger를 추가해 준다.

제작한 애니메이션 :
 - Idle : y축을 살짝 늘리는 것으로 표현
 - Walk : 지금 약간 어색하다. 그냥 걷는 모션임
 - SwordNormal : 무난하다. 위에서 아래로 공격한다.
 - SwordSkill1 : 대검 횡베기 같은 느낌으로 구성해 보았다. 이펙트랑 적절하게 잘 맞는듯 하다.
 - BowNormal : 이 역시 무난하다. 하지만 투사체와의 싱크 문제는 계속해서 고쳐야 할 점이다.
 - BowSkill1 : 매우 만족스러운 애니메이션 중 하난데, 사실 Skill2로 써도 될 만큼 퀄리티가 좋다(...) 튀어오르면서 장전 후 공격한다.
 - MagicNormal : 그냥 완드 공격이다.
 - MagicSkill1 : 지금으로써는 가장 먼저 수정해야 할 애니메이션이다. 지휘자도 아니고..
이 부분을 각각 `SetTrigger` 메소드를 이용해 바뀌도록 하였다.

P.S. 현재 hero가 상대적으로 작다보니 크기를 3으로 맞춰주고, 그에 따라 무기도 전부 키워주었다.


2018/03/07
----------
**향후 UI 개발 계획**
- Start화면 : 메인 이미지 있고, 하단에 `PRESS TO START` 따위의 버튼이 있다. 버튼은 투명하게 해야 함
- 메인 화면 : 큰 맵이 있고, 그 맵을 드래그하면서 이동하며 몬스터 관리, 업그레이드, 용사 땅 공격, 아레나 등으로 이동할 수 있다.
- 마왕의 성 : 마왕 자신을 업그레이드하고, 스킬트리를 찍을 수 있다. 마왕을 업그레이드하면 인게임 마나 리젠율이 상승한다.
- 몬스터 관리 : 몬스터들을 업그레이드하고 룬을 장착할 수 있다.

2018/03/12
----------
**개발 현황**
- 용사 애니메이션 부분을 모두 보완하였다.
- 기존에 사용하던 SetAttackType에서 애니메이션, Instantiate, delayTime을 모두 관리하는 것을 정리하였다.
	- Algorithm Logic
		- 용사의 Fight문 진입
		- `DecideAttackType()` 메소드로 일반, 스킬공격을 정한다.
		- `SetAttackType()`메소드를 이용해 attackAnimation 변수를 설정, 그에 맞는 애니메이션을 먼저 재생시킨다.
		- 각각의 애니메이션에 맞는 애니메이션 시간을 변수에 할당하고, 언제 투사체를 던져줄지도 변수에 할당한다.
		- 이는 각각 `currentAttackDurationTime`과 `shootTime` 변수로 설정된다.
		- 애니메이션을 재생하는 동안 투사체를 던져주는 `Attack()`메소드는 `shootTime`만큼 대기한다.
		- 코루틴의 `yield return new WaitForSeconds(shootTime)` 메소드 이용.
		- 시간이 되면 공격을 하고 마나를 깎아준다.
		- 다음 while문이 돌 때까지 대기하는 시간은 애니메이션 시간에서 투사체를 발사하는데 대기한 시간을 빼준 만큼이다.
		- 따라서 `yield return new WaitForSeconds(currentAttackDurationTime - shootTime)` 을 해주면 완성.
- 법사의 애니메이션을 완성하였다. Skill1은 기존 것보다 나아졌을 것..이라고 생각한다.

2018/03/13
----------
**개발 현황**
- 전체적인 게임 흐름의 코루틴을 추가하였다.
- 게임이 시작하면 초기 설정을 할 수 있는 40초의 시간이 주어진다. 초기 소울값은 100
	- <게임 매니저 기능 추가>
		- 1. 게임 시작하면 40초 동안의 배치 시간
		- 2. 웨이브 한 번(낮)은 5세대씩 들어오게 된다. 시간은 1분 -> 최대 5세대 제한 삭제
		- 3. 웨이브가 끝나면 다시 30초 간의 정비시간
		- 4. 웨이브는 총 다섯회이며 총 25세대가 들어오는 것이다.
		- 즉, 플레이 시간은 한판당 1분 ~ 7분 40초

		- HeroSpawnController 스크립트에 시간과 세대가 흘러가는 전체적인 알고리즘을 추가해 주어야 한다.
		- 1. 상단 아래에는 초가 표시되며 낮 or 밤의 남은 시간이 역산으로 줄어든다.
		- 2. 상단 우측에 웨이브 수와 잡은 용사의 수, 남은 시간을 표시

		- ______________________________________
		- | n웨이브 | (해골) X m | (옵션 버튼) |
		- ______________________________________
		- (소울)
		- ______________________________________
		-               (남은 시간)
		- ______________________________________

		- 3. 항복 버튼 추가! 가망이 없다면 게임을 빨리 끝내는 것이 이득일 것이다. 물론 돈은 적립된다.
		- 4. 게임이 끝나면 잡은 용사의 수에 따라 보상을 받을 수 있다.

		- 웨이브가 끝나면 용사가 있는 위치에 화톳불이 켜지며, 용사는 그 주위에 앉아있게 된다.
		- 용사, 몬스터들 전부 stop. >> 가끔 어둠을 틈타 이동하려는 용사가 있다. >> 터치해서 막아야 함!! >> 용사 : "쳇 들켰군..."
		-        >> 시간내에 몬스터도 배치해야 하고 잡입하려는 용사도 잡아야 하기 때문에 긴장감 상승할 것.
		- 용사가 있는 방에는 몬스터를 배치할 수 없게 해야 한다.
		- !!!!!!!!!한 웨이브에서 용사가 전부 죽어도 웨이브가 끝나야 함!!!!!!!!!! >> 남은시간만큼 소울로 돌려주자.

2018/03/14
----------
**개발 현황**
- 로딩 UI를 추가하였다.
- 게임화면 Top UI를 추가하였다.
* 브라키 성님 찬양해!!!!!!!!!!!

- 오늘 밤 일정 (3/14)
	- laki : 몬스터 배치 기능 
	- crad : 인게임 UI 완성, 스킬 아이콘, 버튼 구성

- 내일 일정 (3/15)
	- laki : 몬스터 Fight, Animation 기능. (MonsterController 및 MonsterController)
	- crad : 월드맵 UI, 마왕 세부정보 UI, 듀토리얼 및 처음 실행한 유저에게만 스토리 나오게끔..

- 모레 일정 (3/16)
	- laki : 
	- crad : 유가족 애니메이션, 소울이나 스킬 애니메이션 및 이펙트 추가, 마왕 스탯 증가 메소드 구현, 화톳불 애니메이션, 기능 구현,


2018/03/15
----------
**개발 현황**
- 인게임 옵션버튼을 추가하였다.
- 옵션버튼을 누르면 게임이 일시정지되면서, 계속하기;다시하기;포기하기 버튼이 있다.
- 다시하기나 포기하기를 누를 경우 지금까지 잡은 용사의 수에 따라 (감소된)보상을 제공한다.
- 포기하기를 누르면 맵 화면으로 넘어간다.
- Monster 1,2,3, SKill1,2 버튼을 추가했다. 각각의 버튼 밑에는 필요한 소울량이 나오고, 사용할 수 없을 때는 빨간색으로 표시된다.
- SKill1을 일단 완성시켰다. `SpawnController.cs`에서 날라갈 Dragon 프리팹과 떨어트릴 Effect를 넣어주고 heroList에서 랜덤으로 세 마리를 선택한 뒤에 그 위에다가 Instantiate시키는 방식으로 구현하였다. heroList에서 hero객체에 접근할 수 있기 때문에 `TVNTCharacterController.cs`에서 lives 인스턴스에 접근하는 것도 가능하다. (체력 깎는 부분 정상 작동)
- 낮과 밤에 따라 맵의 색이 바뀌는 부분을 구현하였다. 이 역시 `SpawnController.cs`에서 tileLight Material과 mainLight의 Color값을 어둡게 바꾸어주는 것으로 구현함.

**오늘 할 것 (crad)**
- 드래곤 Fire Effect 에셋을 정했다 : Fire& Spell Effects // 기존에 있던 레이저는 Skill2로 할 것. 적용까지 할 것!!
- 드래곤 스킬은 Prefab을 생성, 통과시켜서 그에 맞는 Hero들의 체력을 깎아내리는 것으로 구현하자.
- World Map UI 구성, Shadow활용해서 버튼 역동적으로 만들기
- 마왕 세부 스탯 UI 구성, 레벨업 구현 -> 마왕 인스펙터 추가해야 함.
- 듀토리얼 가이드 or 화면 제작
----------------------------------------------------------
- 스킬용 힐링(버프) 이미지 -> 몬스터 리스트를 받아와서 위치에 생성시키고 lives 상승. (active된 몬스터에 한함), 시간 되면 버프효과까지.

**오늘 할 것(laki)**
- World map에서 대륙 두 개 잘라서 보내기
- 경계수치와 히어로 사거리가 잘 작동하는지 확인.
- 몬스터 젠 되었을 때 공격하는지 구현. (애니메이션 확인)
	- HomePosition 구현. (여건 되면)
	- 변수 선언 : Animator myAnimator
	- Start()에서 myAnimator = GetComponent<Animator>();
	- Fight() 함수에서, SetTrigger()로 Animation이름을 주자.
----------------------------------------------------------
- 문 스크립트 적용 및 테스트.
- 화톳불 에셋 검색, 밤에 화톳불 까는 기능 고민


- 현재문제점. DragHandler 에서 Minimap Ray가 제대로 안됨. 이로인해 Level 설정및 level 공격 등 다 틀어짐.
- 몬스터 재사용 문제 죽었을때 setActive로 다 바꾸고, OnEnable로 다시설정해줌
- 내가 타겟한 몬스터한테 못갓는데 죽으면 무한루프.
- 몬스터 이미 있는자리에 배치 못하게 해야함.
- Stuck실행은되나 카운트가 올라가지않음.
- 리치에 있었다가 나간경우말고도 타겟설정했음에도 처음부터 못간 경우도 고려.
- StuckCount 가 미쳐날뜀 왜?
- 문제 잡고, Stuck 몬스터에도 이식해주어야함
- 미니맵 문제 여전 (ray)
- 미니맵 뿐만아니라 ray자체가 문제

- 몬스터 animator 패러미터에 idle 이 없음 / 계속 walk 하고 번갈아가면서 됨(characterController 에 이부분이 있긴함)


2018/03/16
----------
**개발 현황**
- UI를 완성시켰다.
	- WorldMapUI : 스크롤이 가능한 월드맵 기반에 선택할 수 있는 대륙 버튼을 넣어주었다. 옵션 버튼과 상점 버튼이 존재한다.
	- 마왕 땅(My Palace) : 마왕의 스탯과 전적을 확인할 수 있는 공간으로, 모은 골드로 레벨업 또한 가능하다.
	- 스테이지1 : 게임플레이가 가능한 스테이지로, 로딩창을 거친 후에 넘어간다.
- UI에 local DB를 추가하였다. 
	- 유니티가 제공하는 메소드인 `PlayerPrefs.Get~` 과 `PlayerPrefs.Set~`을 이용하여 데이터를 저장하고, 불러오는 구조를 작성하였다.
	- 이 방식은 유니크한 Key값을 이용해서 데이터를 관리할 수 있다. 다만 보안적 측면에서 단점이 있다.
	- 지금까지 추가한 로컬 DB Key
		- int StartCount : 게임을 실행한 횟수
		- int Level : 마왕 레벨
		- int MaxSouls : 최대 소울
		- float RegainSouls : 소울 흡수력
		- float MonsAttack : 몬스터 공격력
		- float MonsShield : 몬스터 방어력
		- int TotalGolds : 총 소지 골드량
		- int RequireGolds : 레벨업에 필요한 골드량
		- int TotalHeroCount : 잡은 용사 수
		- int TotalVillage : 정복한 마을 수
	- 이 외에도 튜토리얼 진행을 위한 Key가 필요하다.
- 마왕 Skill 1,2를 완성시켰다.
	- Skill1은 용이 X모양으로 날아가며 불을 뿜는다. 그 밑에 있는 용사들은 상당한 데미지를 입게 된다.
		- 용이 날아가면서 Update문 안에서 불을 뿜는 Particle Effect를 `Instantiate`하고, 그와 동시에 `FireSphere`를 떨어트린다.
		- `FireSphere`는 1사이즈의 구이며 `GroundFire.cs`가 달려 있다. 
		- `GroundFire.cs`에서는 공이 충돌을 일으켰을 때 땅이 불타는 파티클 이펙트를 생성하게끔 하였다. 물론 Tag값을 비교해 용사가 맞은 경우 용사의 체력을 깎아준다.
	- Skill2는 용사리스트 중에 몇 명을 선택해 레이저를 떨어트리는 구조이다. 이는 03/15 날짜의 Skill1과 동일한 구조라고 보면 된다. 
- 이제 거의 모든 씬을 이어주었다. WorkFlow는 대략 이렇다. (참고로 Build Settings에 이 순서대로 넣어주면 된다.)
	- 0. `Scene:Start`
		- Game Start 버튼을 누른다.
			- 만약 처음 시작하는 사람이라면 : 시나리오 화면을 재생한 뒤에 `Scene:WorldMapUI` 로 이동한다.
	- 1. `Scene:WorldMapUI`
		- Setting 버튼을 누른다.
			- 옵션창을 활성화시키고, 배경 및 효과음을 조절할 수 있게 한다. 가이드와 개발자, 게임종료를 선택할 수 있다.
		- MyPalace 대륙을 누른다.
			- `Scene:Palace`로 이동한다. 
		- Stage 대륙을 누른다.
			- `Scene:V.1.0.2`로 이동한다.
	- 2. `Scene:Palace`
		- 사용자 마왕의 데이터를 불러와 화면에 표시한다.
		- 레벨업 버튼을 누르면 화면이 유동적으로 변화한다.
		- 뒤로가기 버튼을 누른다.
			- `Scene:WorldMapUI`로 이동한다.
	- 3. `Scene:V.1.0.2`
		- 옵션 버튼을 누른다.
			- Resume버튼을 누를 경우 계속한다.
			- Try Again버튼을 누를 경우 `Scene:V.1.0.2`를 리로드한다. (미구현)
			- Give Up버튼을 누를 경우 `Scene:GameOver`로 이동한다. (미구현)
	- 4. `Scene:GameOver` (미구현)


**오늘 할 것(crad)**
- 게임 튜토리얼 구성
	- 튜토리얼을 완료했는지 알 수 있는 Key값을 만들어 수행유무를 판단한다.
	- Start씬에서 썼던 `CanvasFade()`와 유사한 코드를 작성해 화면을 구성하도록 한다.
- 유가족 스크립트 구성
	- 용사가 젠 될때 그 위치 주위에 3~4명의 기본 사람들을 젠 시키도록 한다.
	- 어차피 용사가 연속해서 들어오는 것이 아니기 때문에, 재사용을 해서 위치만 계속 바꾸어주면 될 듯.
	- Speech Controller도 달아줘서 대사가 나오게 구성하자.
- 인게임 몬스터, 스킬 보완
	- 밤과 낮에 따라 몬스터 및 스킬버튼을 Disable 시킨다.
	- 밤이 되면 용사들과 몬스터를 모두 일시정지 시켜야 한다.
		- 일단은 `SpawnController.cs`에 있는 용사만 active를 해제해주자.
		- 그리고 애니메이션을 통해 쉬는 애니메이션을 계속 재생해주자.
- Speech Controller 보완
	- Update문을 통해 카메라의 각도로 보이게끔 구성. 각도차를 계산하면 될 듯
	- 텍스쳐를 좀 더 선명하게 하고, 확대했을 때 보이게끔 한다.
- V.1.0.3 몬스터 애니메이션 구성 : 캐릭터랑 똑같이 구성해볼 것.


2018/03/17
----------
**개발 현황**
- 유가족 기능 구현
	- 용사들이 젠 될 때 주위에서 같이 `Instantiate`되도록 구성하였다.
	- 
- Speech Controller 
	
**오늘 할 것(laki)**
- 몬스터 Fight
- 문 기능 구현
- 대화 트리거 넣기
- 몬스터 출근, 퇴근 기능 구현

**오늘 할 것(crad)**
- 게임 종료 UI 구성
- 다시하기, 항복하기 메뉴 구성
- 소울 먹는 애니메이션(?) 구성
- 용사 화톳불 키고 쉬는 모션 구성

**내일 할 것**
- 시네마틱 타임라인 작성
- 사운드 구성

**모레 할 것**
- 몬스터, 용사 잘 죽는지 확인
- 자잘한 버그 픽스


- 배치 : 그자리에 다른게 있을경우 안되게 했다.
- 배치 : 호버프리팹 만들어준것 MonsterSelect에 연결해서 꺼주도록했다.

- 몬스터 : MonsterAi 전체적인 보완.
- 몬스터 : 현재 싸우는 부분이 제대로 안됨.
- 몬스터 : Stuck 기능 추가해줘야함 (히어로랑 똑같게)

- 스피치 : 커밋중에 스피치 Instantiate & Destroy 다시 살리기 혹은 text 꺼줫다 켜줫다하는 방식이 잇으면 그걸로.
- 스피치 : heroController에서 상황에 따라 SetSituation(Situation.HEROCHAT~)해주면됨.
- 스피치 : 문앞 입장 등등은 문이 완성되야 하므로 일단 문 작업.

-------------------Scene V1.0.5

- 애니메이션 루프꺼주기
